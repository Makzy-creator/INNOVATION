import { Actor, HttpAgent } from '@dfinity/agent';
import { Principal } from '@dfinity/principal';
import { AuthClient } from '@dfinity/auth-client';

// Import the generated declarations (these would be auto-generated by dfx)
interface BloodDonationBackend {
  registerDonor: (name: string, bloodType: string, location: string) => Promise<any>;
  recordDonation: (recipientId: Principal | null, bloodType: string, amount: bigint, location: string) => Promise<any>;
  createBloodRequest: (bloodType: string, amount: bigint, urgency: string, location: string, description: string | null) => Promise<any>;
  getDonations: () => Promise<any[]>;
  getBloodRequests: () => Promise<any[]>;
  getDonorProfile: (donorId: Principal) => Promise<any>;
  fulfillBloodRequest: (requestId: string, donationId: string) => Promise<any>;
  getPlatformStats: () => Promise<any>;
}

interface DonationNFT {
  mintDonationCertificate: (request: any) => Promise<any>;
  getTokenMetadata: (tokenId: bigint) => Promise<any>;
  getTokensByOwner: (owner: Principal) => Promise<bigint[]>;
  getAllTokens: () => Promise<any[]>;
  transferToken: (tokenId: bigint, to: Principal) => Promise<any>;
}

class ICPService {
  private authClient: AuthClient | null = null;
  private agent: HttpAgent | null = null;
  private bloodDonationActor: BloodDonationBackend | null = null;
  private nftActor: DonationNFT | null = null;
  private isAuthenticated = false;

  // Canister IDs (these would be set after deployment)
  private readonly BLOOD_DONATION_CANISTER_ID = process.env.VITE_BLOOD_DONATION_CANISTER_ID || 'rdmx6-jaaaa-aaaah-qcaiq-cai';
  private readonly NFT_CANISTER_ID = process.env.VITE_NFT_CANISTER_ID || 'rrkah-fqaaa-aaaah-qcuiq-cai';

  async initialize() {
    try {
      this.authClient = await AuthClient.create();
      
      // Check if already authenticated
      if (await this.authClient.isAuthenticated()) {
        await this.setupAgent();
        this.isAuthenticated = true;
      }
    } catch (error) {
      console.error('Failed to initialize ICP service:', error);
    }
  }

  async login(): Promise<boolean> {
    if (!this.authClient) {
      await this.initialize();
    }

    return new Promise((resolve) => {
      this.authClient!.login({
        identityProvider: process.env.NODE_ENV === 'production' 
          ? 'https://identity.ic0.app'
          : `http://localhost:4943/?canisterId=${process.env.VITE_INTERNET_IDENTITY_CANISTER_ID}`,
        onSuccess: async () => {
          await this.setupAgent();
          this.isAuthenticated = true;
          resolve(true);
        },
        onError: (error) => {
          console.error('Login failed:', error);
          resolve(false);
        }
      });
    });
  }

  async logout() {
    if (this.authClient) {
      await this.authClient.logout();
      this.isAuthenticated = false;
      this.agent = null;
      this.bloodDonationActor = null;
      this.nftActor = null;
    }
  }

  private async setupAgent() {
    if (!this.authClient) return;

    const identity = this.authClient.getIdentity();
    
    this.agent = new HttpAgent({
      identity,
      host: process.env.NODE_ENV === 'production' ? 'https://ic0.app' : 'http://localhost:4943'
    });

    // Fetch root key for local development
    if (process.env.NODE_ENV !== 'production') {
      await this.agent.fetchRootKey();
    }

    // Create actors
    this.bloodDonationActor = Actor.createActor<BloodDonationBackend>(
      ({ IDL }) => IDL.Service({
        registerDonor: IDL.Func([IDL.Text, IDL.Text, IDL.Text], [IDL.Variant({ ok: IDL.Record({}), err: IDL.Text })], []),
        recordDonation: IDL.Func([IDL.Opt(IDL.Principal), IDL.Text, IDL.Nat, IDL.Text], [IDL.Variant({ ok: IDL.Record({}), err: IDL.Text })], []),
        createBloodRequest: IDL.Func([IDL.Text, IDL.Nat, IDL.Text, IDL.Text, IDL.Opt(IDL.Text)], [IDL.Variant({ ok: IDL.Record({}), err: IDL.Text })], []),
        getDonations: IDL.Func([], [IDL.Vec(IDL.Record({}))], ['query']),
        getBloodRequests: IDL.Func([], [IDL.Vec(IDL.Record({}))], ['query']),
        getDonorProfile: IDL.Func([IDL.Principal], [IDL.Opt(IDL.Record({}))], ['query']),
        fulfillBloodRequest: IDL.Func([IDL.Text, IDL.Text], [IDL.Variant({ ok: IDL.Text, err: IDL.Text })], []),
        getPlatformStats: IDL.Func([], [IDL.Record({})], ['query']),
      }),
      {
        agent: this.agent,
        canisterId: this.BLOOD_DONATION_CANISTER_ID,
      }
    );

    this.nftActor = Actor.createActor<DonationNFT>(
      ({ IDL }) => IDL.Service({
        mintDonationCertificate: IDL.Func([IDL.Record({})], [IDL.Variant({ ok: IDL.Nat, err: IDL.Text })], []),
        getTokenMetadata: IDL.Func([IDL.Nat], [IDL.Opt(IDL.Record({}))], ['query']),
        getTokensByOwner: IDL.Func([IDL.Principal], [IDL.Vec(IDL.Nat)], ['query']),
        getAllTokens: IDL.Func([], [IDL.Vec(IDL.Record({}))], ['query']),
        transferToken: IDL.Func([IDL.Nat, IDL.Principal], [IDL.Variant({ ok: IDL.Text, err: IDL.Text })], []),
      }),
      {
        agent: this.agent,
        canisterId: this.NFT_CANISTER_ID,
      }
    );
  }

  // Donation functions
  async registerDonor(name: string, bloodType: string, location: string) {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.registerDonor(name, bloodType, location);
  }

  async recordDonation(recipientId: string | null, bloodType: string, amount: number, location: string) {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    
    const recipient = recipientId ? Principal.fromText(recipientId) : null;
    const result = await this.bloodDonationActor.recordDonation(recipient, bloodType, BigInt(amount), location);
    
    // If donation recorded successfully, mint NFT certificate
    if ('ok' in result) {
      await this.mintDonationNFT(result.ok, bloodType, amount, location);
    }
    
    return result;
  }

  async createBloodRequest(bloodType: string, amount: number, urgency: string, location: string, description?: string) {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.createBloodRequest(
      bloodType, 
      BigInt(amount), 
      urgency, 
      location, 
      description || null
    );
  }

  async getDonations() {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.getDonations();
  }

  async getBloodRequests() {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.getBloodRequests();
  }

  async fulfillBloodRequest(requestId: string, donationId: string) {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.fulfillBloodRequest(requestId, donationId);
  }

  async getPlatformStats() {
    if (!this.bloodDonationActor) throw new Error('Not authenticated');
    return await this.bloodDonationActor.getPlatformStats();
  }

  // NFT functions
  async mintDonationNFT(donationData: any, bloodType: string, amount: number, location: string) {
    if (!this.nftActor) throw new Error('Not authenticated');
    
    const identity = this.authClient?.getIdentity();
    if (!identity) throw new Error('No identity available');

    const mintRequest = {
      to: identity.getPrincipal(),
      donationId: donationData.id,
      bloodType,
      amount: BigInt(amount),
      location,
      timestamp: BigInt(Date.now() * 1000000) // Convert to nanoseconds
    };

    return await this.nftActor.mintDonationCertificate(mintRequest);
  }

  async getUserNFTs() {
    if (!this.nftActor) throw new Error('Not authenticated');
    
    const identity = this.authClient?.getIdentity();
    if (!identity) throw new Error('No identity available');

    const tokenIds = await this.nftActor.getTokensByOwner(identity.getPrincipal());
    
    // Get metadata for each token
    const nfts = await Promise.all(
      tokenIds.map(async (tokenId) => {
        const metadata = await this.nftActor!.getTokenMetadata(tokenId);
        return { tokenId, ...metadata };
      })
    );

    return nfts.filter(nft => nft !== null);
  }

  async transferNFT(tokenId: number, toAddress: string) {
    if (!this.nftActor) throw new Error('Not authenticated');
    return await this.nftActor.transferToken(BigInt(tokenId), Principal.fromText(toAddress));
  }

  async getAllNFTs() {
    if (!this.nftActor) throw new Error('Not authenticated');
    return await this.nftActor.getAllTokens();
  }

  // Utility functions
  isConnected(): boolean {
    return this.isAuthenticated;
  }

  getPrincipal(): Principal | null {
    return this.authClient?.getIdentity().getPrincipal() || null;
  }

  getPrincipalText(): string | null {
    const principal = this.getPrincipal();
    return principal ? principal.toText() : null;
  }
}

export default new ICPService();